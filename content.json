{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"threst","url":"https://threst.github.io"},"pages":[],"posts":[{"title":"isccwp","slug":"isccwp","date":"2018-05-12T09:33:09.000Z","updated":"2018-05-13T14:24:38.013Z","comments":true,"path":"2018/05/12/isccwp/","link":"","permalink":"https://threst.github.io/2018/05/12/isccwp/","excerpt":"","text":"iscchashdump长度碰撞&lt;?phpinclude “secret.php”;@$username=(string)$_POST[‘username’];function enc($text){ global $key; return md5($key.$text);}if(enc($username) === $_COOKIE[‘verify’]){ if(is_numeric(strpos($username, “admin”))){ die($flag); } else{ die(“you are not admin”); }}else{ setcookie(“verify”, enc(“guest”), time()+6060247); setcookie(“len”, strlen($key), time()+6060247);}show_source(FILE);`主要要注意这个$key的长度根据返回包的len参数为46,所以hashdump长度输入46,在本地测试可以把inlcude这行删掉，自己定义$key,$flag 逆向第一题[原题wp]：(https://blog.csdn.net/xiangshangbashaonian/article/details/79575062)openssl rsa -pubin -text -modulus -in warmup -in public.keyPublic-Key: (256 bit)Modulus: 00:d9:9e:95:22:96:a6:d9:60:df:c2:50:4a:ba:54: 5b:94:42:d6:0a:7b:9e:93:0a:ff:45:1c:78:ec:55: d5:55:ebExponent: 65537 (0x10001)Modulus=D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EBwriting RSA key—–BEGIN PUBLIC KEY—–MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK/0UceOxV1VXrAgMBAAE=—–END PUBLIC KEY—–`python一下a = 0xd99e952296a6d960dfc2504aba545b9442d60a7b9e930aff451c78ec55d555ebprint a = 98432079271513130981267919056149161631892822707167177858831841699521774310891L放到这个[网站]上面试试分解(http://factordb.com/index.php)最终代码: #coding:utf-8import gmpyimport rsap = 302825536744096741518546212761194311477q = 325045504186436346209877301320131277983n = 98432079271513130981267919056149161631892822707167177858831841699521774310891e = 65537d = int(gmpy.invert(e , (p-1) * (q-1)))privatekey = rsa.PrivateKey(n , e , d , p , q) #根据已知参数，计算私钥with open(&quot;encrypted.message1&quot; , &quot;rb&quot;) as f:print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印with open(&quot;encrypted.message2&quot; , &quot;rb&quot;) as f:print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印with open(&quot;encrypted.message3&quot; , &quot;rb&quot;) as f:print(rsa.decrypt(f.read(), privatekey).decode()) #使用私钥对密文进行解密，并打印 iscc cbc翻转攻击打开网页查看注释提示tips:index.txt打开index.txt看到源码，审计一波&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();`function get_random_iv(){ $iv=’’; for($i=0;$i&lt;16;$i++){ $iv.=chr(rand(1,255)); } return $iv;}function login($info){ $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[‘username’] = $info[‘username’]; setcookie(“iv”, base64_encode($iv)); setcookie(“cipher”, base64_encode($cipher));}function show_homepage(){ if ($_SESSION[“username”]===’admin’){ echo ‘Hello admin‘; echo ‘Flag is **‘; }else{ echo ‘hello ‘.$_SESSION[‘username’].’‘; echo ‘Only admin can see flag‘; } echo ‘Log out‘; die();}function check_login(){ if(isset($_COOKIE[‘cipher’]) &amp;&amp; isset($_COOKIE[‘iv’])){ $cipher = base64_decode($_COOKIE[‘cipher’]); $iv = base64_decode($_COOKIE[“iv”]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(“base64_decode(‘“.base64_encode($plain).”‘) can’t unserialize“); $_SESSION[‘username’] = $info[‘username’]; }else{ die(“ERROR!”); } }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {` ` $username=waf((string)$_POST[&#39;username&#39;]);` ` $password=waf((string)$_POST[&#39;password&#39;]);` ` if($username === &#39;admin&#39;){` ` exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);` ` }else{` ` $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);` ` login($info);` ` show_homepage();` ` }` `}` `else{` ` if(isset($_SESSION[&quot;username&quot;])){` ` check_login();` ` show_homepage();` ` }` `}` `?&gt;` `开始我们尝试直接username=admin，password=admin结果输出You are not real admin! 因为这行代码判断username不能为admin if($username === &#39;admin&#39;){ exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;); 此题与[这题](http://118.89.219.210:49168/index.php)相似 存在index.php.swp， `vim -r index.php.swp` 继续iscc 首先发送xdmin，12345，在返回包里存在iv，cipher参数import base64`import requests`import urllib`iv_raw=’%2F8iEm4jh%2BjbgVGwlQ31ycg%3D%3D’ #这里填写第一次返回的iv值`cipher_raw=’8WdhbPxjZy9xYAgoCeghiOUQu0ri1Y3dv7cX44MbvOfIC6zZxCbR%2FPFpeMatL5qIgT%2BYA66tIdCBpxtWsWxV9Q%3D%3D’ #这里填写第一次返回的cipher值`print “[]原始iv和cipher”`print “iv_raw: “ + iv_raw`print “cipher_raw: “ + cipher_raw`print “[]对cipher解码，进行反转”`cipher = base64.b64decode(urllib.unquote(cipher_raw))`#a:2:{s:8:”username”;s:5:”zdmin”;s:8:”password”;s:5:”12345”}`#s:2:{s:8:”userna`#me”;s:5:”zdmin”;`#s:8:”password”;s`#:3:”12345”;}`xor_cipher = cipher[0:9] + chr(ord(cipher[9]) ^ ord(‘m’) ^ ord(‘a’)) + cipher[10:] #请根据你的输入自行更改，原理看上面的介绍`xor_cipher=urllib.quote(base64.b64encode(xor_cipher))`print “反转后的cipher：” + xor_cipher在post包中的cookie中添加iv，cipher，iv的参数用放回包中的，cipher使用反转后的cipher，再发包 可以看见返回包中有串base64_decode()import base64import urllibcipher = ‘Bc6oENSSAEPpPdv/rbqRZG1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9’#填写提交后所得的无法反序列化密文iv = ‘%2F8iEm4jh%2BjbgVGwlQ31ycg%3D%3D’#一开始提交的iv#cipher = urllib.unquote(cipher)cipher = base64.b64decode(cipher)iv = base64.b64decode(urllib.unquote(iv))newIv = ‘’right = ‘a:2:{s:8:”userna’#被损坏前正确的明文for i in range(16): newIv += chr(ord(right[i])^ord(iv[i])^ord(cipher[i])) #这一步相当于把原来iv中不匹配的部分修改过来print urllib.quote(base64.b64encode(newIv))`解密这串base64,加到iv参数中，再post，出flag","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://threst.github.io/tags/周报/"}]},{"title":"艰难的hexo上线","slug":"艰难的hexo上线","date":"2018-05-12T09:33:09.000Z","updated":"2018-05-12T13:28:38.544Z","comments":true,"path":"2018/05/12/艰难的hexo上线/","link":"","permalink":"https://threst.github.io/2018/05/12/艰难的hexo上线/","excerpt":"","text":"写在前面的话之前一直想搭个博客记录一下学习,也算是监督,办域名弄空间太麻烦了,于是打算就是使用github+hexo搭个静态的. kali下的尝试在网上搜了下全是关于windows和mac下的,并没有linux下的,更别说kali,要搭hexo首先要以下条件:1.nodejs2.git3.hexo开始发现kali自带nodejs,大喜!但是喜不过三秒,npm命令找不到,各种尝试,个个失败:(突然发现可以重装node,于是卸载node,然后又在弄npm和node的链接,npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm install hexo-cli -gcd /node-v4.9.1-linux-x64/lib/node_modules/hexo-cli/bin./hexo -v终于有hexo了hexo -init提示not empty, please run hexo init on an empty folder and then copy your files into itsudo ln -s /home/threst/node-v4.9.1-linux-x64/lib/node_modules/hexo-cli/bin /hexo /usr/local/bin/hexomkdir hexocd hexohexo init创建好了，可是使用npm install没有回显提示hexo失败!!!! win7尝试因为去装了个移动硬盘原来那个kali系统不用了,所以要重新安装虚拟机,这里又是个坑,虚拟机各种报错,后来发现没有apt upgrade 正式安装1.下载git,nodejs2.github创建gitpage项目3.npm install hexo -g4.hexo -v检查是否安装成功5.新建hexo文件夹,进入hexo init安装hexo6.npm install7.在hexo文件夹中右键,git bash8.git config --global user.name &quot;threst&quot; git config --global user.email &quot;qq.com&quot;9.ssh-keygen -t rsa -C &quot;qq.com&quot;10.在github中添加ssh key,输入id_rsa.pub11.ssh -T git@github.com The authenticity of host ‘github.com (13.250.177.223)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,13.250.177.223’ (RSA) to the list of known hosts.Hi threst! You’ve successfully authenticated, but GitHub does not provide shell access. ssh可以连接这里又是个坑,hexo d的时候总是传不到github上去,只有本地有,问了些大佬,都没这种问题,后来发现repo有两种方式,只有这种可以,之前试的是https://threst/threst.github.io.gitdeploy: type: git repo: git@github.com:threst/threst.github.io.git branch: master13.提示ERROR Deployer not found: gitnpm install hexo-deployer-git --save14.hexo clean hexo g hexo d测试0k 安装主题在hexo文件夹中打开gitbashnpm install hexo-generator-json-content --save &amp;&amp; git clone https://github.com/fi3ework/hexo-theme-archer.git themes/archer在_config.yml中设置theme: archer 最后的坑1.主题中_config的图片不用加引号2.favion我没有写所以在_config中把那行直接去掉,而不是不填这两点都可导致页面打开404或空白(重装5遍)","categories":[],"tags":[]},{"title":"逆向入门--ARM64的linux","slug":"逆向工程入门— ARM64上的Linux","date":"2018-05-12T09:33:09.000Z","updated":"2018-05-13T14:31:40.124Z","comments":true,"path":"2018/05/12/逆向工程入门— ARM64上的Linux/","link":"","permalink":"https://threst.github.io/2018/05/12/逆向工程入门— ARM64上的Linux/","excerpt":"","text":"序幕正如您知道的那样，ARM为我们周围的各种低功耗设备供电，包括但不限于电话，路由器，物联网设备等。因此，深入研究这种体系结构并理解它与x86和x64体系结构有何不同之处是合理的。对于这篇文章，我们将重点介绍目前最常用的64位ARM CPU。我们的设备包括ARM Cortex-A53 CPU的Ubuntu 16.04，它支持32位和64位指令集。 在之前的文章中，我们逆向了x64Linux和Windows中的C++二进制文件。在这篇文章中，我们将会使用同样的程序，但用c语言重写。 编译程序：$ gcc crack_me.c -o crack_me ####二进制信息： 反编译现在让我们用启动GDB二进制并开始分析。请注意，我使用GEF（https://github.com/hugsy/gef）和GDB，所以我的提示符看起来像gef&gt;而不是gdb&gt;。我们先分解一下主要功能。 $ gdb ./crack_me gef&gt; disas main 我们的注意力直接转向&lt;main + 64&gt;处的&lt;check_pass&gt;函数，但在之前，您可能需要花点时间并理解这些指令的含义。您可以在ARM的文档（https://developer.arm.com/docs/100069/latest/a64-general-instructions）上阅读更多关于这些内容的信息。以下是对我们的分析很重要的一些说明。 b -分支到标签，类似于jmp语句bl -分支到链接到标签，类似于调用语句b.ne -分支到标签，如果不相等，类似于jne语句b.eq -分支到标签，如果相等，类似于je声明 让我们深入汇编代码。编号是指在gdb反汇编输出中突出显示的部分。 1.在地址0x4007bc， &lt;main+4&gt;，堆栈指针（SP）寄存器是MOV “ED寄存器X29。然后我们注意到从x29寄存器访问的主要函数参数。请注意，x29寄存器的偏移量28包含argc，而偏移量16包含argv（这是我们的输入密码）。在比较argc值时，如果它等于0x2，我们将（b.eq – branch if equal)分支到&lt;main + 52&gt;。2.接下来的三行&lt;main + 52&gt;，&lt;main + 56&gt;和&lt;main + 60&gt;将argv字符串的大小从16扩展到24（16 + 0x8 = 24），并由x0寄存器引用。3.然后我们调用（bl – branch with link）到&lt;check_pass&gt;函数。 我们来拆开&lt;check_pass&gt;函数。 gef&gt; disas check_pass 4.在地址 0x400738,&lt;check_pass+8&gt;，新的argv字符串从x0寄存器复制到x29寄存器。偏移量为24。然后，我们看到一些堆栈的canary操作，从&lt;check_pass+12&gt;到&lt;check_pass+24&gt;，有一些被储存在x29寄存器中，地址是0x411048，然后在函数的末尾，从&lt;check_pass + 96&gt;开始，直到&lt;check_pass + 124&gt;。5.回到&lt;check_pass&gt;函数的主体，我们看到从&lt;check_pass + 32&gt;开始，有些东西被访问从0x4008d0，并被储存到x29寄存器中，有偏移0x28(40)，可能是秘密密码?6.然后从&lt;check_pass + 60&gt;开始，x1寄存器指向从0x4008d0和x0寄存器中新复制的数据到x29寄存器中的argv字符串，偏移量为24，然后调用strcmp (x0 &amp; x1)函数。strcmp函数的返回值存储在16位通用w0寄存器中。如果字符串相等，则w0设置为0x0，否则设置为0x1。 回到&lt;main&gt;功能… 7.&lt;check_pass&gt;函数的返回值存储在w0寄存器中，该值被复制到偏移量为44的x29寄存器中。然后在&lt;main + 76&gt;处比较w0寄存器的值以查看它是否等于0x1。如果不是，我们跳转（b.ne – branch if not equal)到&lt;main + 100&gt;，这将导致我们获得成功消息，最后退出程序。现在我们将用错误的密码启动该程序。但在此之前，我们必须在&lt;main + 76&gt;的比较语句中添加断点。 gef&gt; break *0x400804 gef&gt; run pass123 我们在0x400804，&lt;main+76&gt;的比较语句中击中了断点另外，请注意x0寄存器的值是0x1。因为，x0指针只是w0寄存器+ 32位额外位，x0包含&lt;check_pass&gt;函数的返回值。从源代码中，我们知道程序将检查check_pass函数的返回值是否为1，以显示“错误密码”消息。因此，该值应该是除了0x1之外的任何值，以便程序向我们显示成功消息。 让我们改变它的价值… gef&gt; set $x0=0x0 现在让我们继续执行。 gef&gt; continue 结语原来我们的假设是正确的。将x0的值从0x1更改为0x0的技巧。这意味着它会一直检查w0是否设置为0x1来显示不正确的消息，我们从程序的源代码中知道这一点。因此，回到&lt;check_pass&gt;函数，我们注意到从地址0x4008d0复制了一些东西。我们来检查一下。 这看起来不像任何有效的汇编指令，但53的重复是可疑的，41也是十六进制的&#39;A‘。这绝对看起来像一个常量字符串。让我们看看更深。从我们的地址0x4008d0转储10多行… 查看0x4008d0和0x4008d4，我们可以看出它是little-endian 8位字符串。让我们尝试解码它… 这里我们有原始密码“ PASSWORD ”。 这只是使用gdb分析二进制文件在不同的体系结构中的一个例子。展望未来，我们将处理更复杂的程序，不常见的架构和更奇怪的二进制文件。原文地址：https://scriptdotsh.com/index.php/2018/04/26/ground-zero-part-3-reverse-engineering-basics-linux-on-arm64/","categories":[],"tags":[{"name":"安全客弃婴","slug":"安全客弃婴","permalink":"https://threst.github.io/tags/安全客弃婴/"}]},{"title":"逆向入门--linux64","slug":"逆向工程基础 - Linux x64","date":"2018-05-12T09:33:09.000Z","updated":"2018-05-13T14:27:12.061Z","comments":true,"path":"2018/05/12/逆向工程基础 - Linux x64/","link":"","permalink":"https://threst.github.io/2018/05/12/逆向工程基础 - Linux x64/","excerpt":"","text":"序幕这个Ground Zero系列适合初学者入门使用，让他们进入逆向工程领域。因为这是x64的时代，所以我跳过了x86体系结构。但是你要知道，所有将用c++编写的示例也可以编译为x86，但是我将把它作为作业留给你们。如果你没有任何经验，也无所谓了。你唯一需要的就是有对编程语言的基本理解。开始时，我们将编写一个简单的c++程序，它将提示用户输入密码。它将检查密码是否匹配，如果它正确，它将提示正确，否则将提示错误。我举这个例子的主要原因是，这个例子将让你了解jump，以及其他类似的条件在汇编语言中是如何工作的。另一个原因是，大多数具有硬编码键的程序都可以用类似的方式破解，只不过需要更多的数学知识，而这正是大多数盗版分销商如何破解合法软件并传播密钥的方式。让我们先了解一下我们编写的c++程序。所有的代码都将托管在我的Github页面中：https://github.com/paranoidninja/ScriptDotSh-Reverse-Engineering 这里的代码非常简单。我们的程序将一个参数作为密码输入，如果我不输入任何密码，它将打印help命令。如果我指定了一个密码，它会以10个字节的字符形式存储，并将密码发送到check_pass()函数。我们的硬编码密码是check_pass()函数中的PASSWORD1。在这里，我们的密码与strcmp90函数的实际密码变量mypass进行比较。如果密码匹配，则返回零，否则返回1。返回到我们的主功能，如果我们接收到1，它会打印错误的密码，否则会打印正确的密码。 现在，让我们在GDB调试器中找到这个代码。用GDB执行二进制文件，将首先在main中设置一个断点，然后再发送参数。其次，我们会让enable time在我们的GDB上运行，所以如果我们走错了一步，我们可以逆转这一步。这可以通过以下命令完成：target record-full和reverse-stepi / nexti 如果你不明白这一点，问题不大。你只需关注gdb $部分，就像你上面看到的那样，在给断点使用break main之后，我输了一个错误的密码pass123。我的编译过的代码应该如前所述打印一个不正确的密码，但是随着我们继续，我们会找到两种方法来绕过代码; 一种是通过从内存中取出实际密码，二是通过修改跳转值并打印密码正确。 反汇编下一步是反汇编整个代码，看看到底发生了什么： 我们在整个反汇编代码中的主要关注以下几点： 1.je - je表示如果相等就跳转到某个地址，如果不相等，继续下一步。2.call-调用一个新的函数。请记住，在加载完成后，反汇编代码将从主反汇编函数更改为新函数的反汇编代码。 test - 检查两个值是否相等 cmp- 比较两个值 JNE - 如果它不等于某物，jne就意味着跳转。否则，继续下一步。 有些人可能会问，既然我们有cmp，我们为什么要进行test呢?答案可以在这里找到，解释得很漂亮:https://stackoverflow.com/questions/39556649/linux-assembly-whats-difference-between-test-eax-eax-and-cmp-eax-0 所以，如果我们看到上面的反汇编代码，我们知道如果我们运行没有密码或参数的二进制文件，它将打印帮助，否则将继续检查密码。所以这个cmp应该是检查我们是否有参数的部分。如果一个参数不存在，它将继续打印帮助，否则它将跳转到&lt;main + 70&gt;。如果你在左边的地址旁边看到那些数字，我们可以看到在&lt;+70&gt;处，我们正在将某些东西移动到rax寄存器中。所以，我们要做的是我们将在je上设置一个断点，方法是指定它的地址0x0000000000400972，然后看看它是跳转到&lt;+70&gt;通过要求它继续c。GDB命令c将继续运行二进制文件，直到遇到另一个断点。 而现在，如果您执行的是step迭代的stepi，它将执行一次迭代执行，并且它应该将您带到&lt;+70&gt;它将Quad Word移入rax寄存器的位置。 我们的逻辑到现在为止都是正确的，现在我们来看下一个有趣的东西，也就是调用部分。如果你看到它旁边，它上面写着类似于&lt;_Z10check_passPc&gt;，它就是我们的check_pass()函数。让我们跳到使用stepi，看看函数里面是什么。一旦你跳到check_pass()函数并反汇编它，你会看到一组新的反汇编代码，它就是check_pass()函数本身的代码。这里有四行有趣的代码： 第一部分是将rdx寄存器的值移至rsi并将rax移至rdi。下一部分是调用strcmp()函数，它是C ++的字符串比较函数。接下来，我们有测试这两个值进行比较，如果这两个值相等，我们跳（JE）到&lt;_Z10check_passPc + 77&gt;将0移动到EAX寄存器。如果值不相等，函数将继续在&lt;+70&gt;处继续并在eax寄存器赋值1。现在，这些只不过是我们先前在check_pass()函数中指定的返回值。由于我们输入了无效密码，将发送的返回值为1。但是如果我们可以将返回值修改为零，那么它将输出为“正确的密码”。 另外，我们可以继续检查被移动到rsi和rdi寄存器中的内容。所以，让我们在那里放置一个断点并直接跳到它。 从上图可以看出，我使用了x / s $ rdx和x / s $ rax命令从寄存器中获取值。x / s表示检查寄存器并将其显示为一个字符串。如果你想以字节为单位获得它，你可以指定x / b，或者如果你想要字符，你可以指定x / c等等。然而，有多种变化。现在我们获取密码的第一部分已经在这里了。但是，让我们看看我们如何将&lt;_Z10check_passPc + 70&gt;处的返回值修改为零。所以，我们会拍摄stepi并跳到这个迭代。 结语正如您在上面看到的，函数在二进制中将0x1移到eax，但是在它可以做一个je之前，我们使用set $eax = 0x0将值修改为0x0，然后继续使用c作为下面的函数，瞧!!!我们有一个返回的值作为正确的密码! 这只是一个简单的例子，让您开始逆向工程。随着我们深入，我们将看到套接字函数，运行时加密，编码隐藏的域名等等。这整个过程可以在Windows中使用Olly调试器完成，我将在下一篇博文中展示。 原文地址:https://scriptdotsh.com/index.php/2018/04/09/ground-zero-part-1-reverse-engineering-basics/","categories":[],"tags":[{"name":"安全客弃婴","slug":"安全客弃婴","permalink":"https://threst.github.io/tags/安全客弃婴/"}]}]}